#!/usr/bin/env zsh
# shellcheck shell=bash # ?? Shellcheck doesn't officially support Zsh linting, Bash is a close enough analog in most cases.

# Comment styling
# ** Highlight
# ?? Informational
# <> annotations for whole code blocks, i.e purpose of a function, bracegroup, loop, etc.
# !! Important
# ~~ Invalidated
# (TODO) Todo comments
# (WIP) Work in Progress
# (ACK) acknowledgment
# (RegEx) additional explanations for RegEx

zmodload zsh/datetime # ** $EPOCHREALTIME is provided by zsh/datetime, thus it has to be loaded before the first use of that variable.
declare -gA timing; timing[all]="$EPOCHREALTIME"
### **=====User settings=====**
zsh_script_dir="$HOME/.config/zsh/scripts" # "plugin" script location
update_frequency="7d" # ?? interval between update checks. Format: 1w2d3h4m5s (case insensitive); Default: 7d
### **=======================**

function setup(){ # <> General setup that has to run regardless of shell level

timing[plugin_list]="$EPOCHREALTIME"
declare -gA plugins=( # ?? List plugins you wish to use by repo URL
                 [col_gen]="$zsh_script_dir/col_gen/col_gen.sh" # local
                 [percode]="$zsh_script_dir/percode/percode.sh" # local
            [shared_agent]="$zsh_script_dir/shared_agent/shared_agent.sh" # local
               [shell_pad]="$zsh_script_dir/shell_pad/shell_pad.zsh" # local
                  [typeof]="$zsh_script_dir/typeof/typeof.sh" # local
     [zsh-autosuggestions]="https://github.com/zsh-users/zsh-autosuggestions"
         [zsh-completions]="https://github.com/zsh-users/zsh-completions"
 [zsh-syntax-highlighting]="https://github.com/zsh-users/zsh-syntax-highlighting"
)
timing[plugin_list]=$(printf '%8.2f%s' "$(( (EPOCHREALTIME - timing[plugin_list]) * 1000 ))" "ms â”‚  â”Œâ”€ List expected plugins - setup:$LINENO")

timing[color]="$EPOCHREALTIME"
### Color palette array for easier colorization
declare -A per; per=( # Permutations for foreground and background
    [fg_]="38;2;"
    [bg_]="48;2;"
)

# <> We need a sorted, associative array for the palette.
declare -A pal; local pal=( # [name]="r ; g ; b " # ** Associative arrays are unsorted
       [black]="10;4;"       # #0A0400
         [red]="214;30;28"   # #D61E1C
       [green]="29;166;90"   # #1DA65A
      [yellow]="237;188;"    # #EDBC00
        [blue]="10;117;173"  # #0A75AD
     [magenta]="255;51;184"  # #FF33B8
        [cyan]=";206;241"    # #00CEF1
  [light_grey]="176;178;180" # #B0B2B4
   [dark_grey]="79;77;75"    # #4F4D4B
   [light_red]="224;60;49"   # #E03C31
 [light_green]="105;180;32"  # #64B141
      [orange]="226;109;14"  # #E26D0E
   [dark_blue]="41;82;178"   # #2952B2
      [purple]="144;16;240"  # #9010F0
        [zomp]="57;167;173"  # #39A78E
       [white]="245;251;255" # #F5FBFF
)

declare -a pal_order; local pal_order=( # ** order of `pal[]`, regular arrays are sorted
"black"       # 0
"red"         # 1
"green"       # 2
"yellow"      # 3
"blue"        # 4
"magenta"     # 5
"cyan"        # 6
"light_grey"  # 7
"dark_grey"   # 8
"light_red"   # 9
"light_green" # 10
"orange"      # 11
"dark_blue"   # 12
"purple"      # 13
"zomp"        # 14
"white"       # 15
)

# <> Use col_gen expand `pal[]` to 256 Colors
: "${pal_order[@]}" # (WIP) Still being worked on
# shellcheck source=/dev/null # ?? Shellcheck doesn't parse external sources by default
# source "${plugins[col_gen]}" # ** exports function `col_gen()`
# col_gen "${pal_order[@]}" "${pal[@]}"

declare -gA col
# shellcheck disable=SC2068,SC2296 # ?? Shellcheck doesn't understand Zsh's method for looping over associative array keys.
# <> These two for loops dynamically build the `col[]` array from the permutations of `per[]` and `pal[]`
for mut in ${(k)per[@]}; do # assign the keys of `per[]` to $mut
    for color in ${(k)pal[@]}; do # assign the keys of `pal[]` to $color
        col[$mut$color]="\e[${per[$mut]}${pal[$color]}m" # index names follow the pattern ${col[<fg/bg>_<color>]}
    done
done

col+=( # ** append the following sequences to the `col[]` array
     [reset]="\e[0m"  # reset all escape sequences
  [fg_reset]="\e[39m" # reset foreground only
  [bg_reset]="\e[49m" # reset background only
      [bold]="\e[1m"
       [dim]="\e[2m"  # dimmed color
    [no_dim]="\e[22m" # also resets bold
      [ital]="\e[3m"  # italic
   [no_ital]="\e[23m"
     [uline]="\e[4m"  # underline
  [no_uline]="\e[24m"
     [blink]="\e[5m"  # blinking text
  [no_blink]="\e[25m"
       [inv]="\e[7m"  # swapped foreground and background
    [no_inv]="\e[27m"
    [strike]="\e[9m"  # strikethrough
 [no_strike]="\e[29m"
)
timing[color]=$(printf '%8.2f%s' "$(( (EPOCHREALTIME - timing[color]) * 1000 ))" "ms â”‚  â”œâ”€ Color Palette Generation - setup:$LINENO")

timing[debug]="$EPOCHREALTIME"
declare -ga debug_valid=( # valid values for $debug_verbosity, set with the `-v|--verbose <value>` flag.
"all"
"args"
"banner"
"color"
"installed"
"missing"
"off"
"ssh"
"updates"
)
debug_verbosity=''

timing[debug]=$(printf '%8.2f%s' "$(( (EPOCHREALTIME - timing[debug]) * 1000 ))" "ms â”‚  â”œâ”€ Define valid debug values - setup:$LINENO")
}; setup; timing[setup]=$(printf '%8.2f%s' "$(( (EPOCHREALTIME - timing[all]) * 1000 ))" "ms â”œâ”€ setup() - L:$LINENO")

function main(){ # <> contains everything that only needs to run when setting up a un-nested shell

[[ $debug_verbosity =~ ^(color|all)$ ]] && { ## Debug: Color # (RegEx) Only define this if $debug_verbosity is 'color' or 'all'
        echo -e "${col[fg_purple]}[${col[reset]}=====${col[fg_purple]}DEBUG${col[reset]}=====${col[fg_purple]}]${col[reset]}"
            # (WIP) Redoing color debugging
            # shellcheck source=/dev/null # ?? Ignore Shellcheck's inability to parse external sources by default
            source "$zsh_script_dir/shell-pad/shell-pad.zsh" "${col[@]}" || echo "under construction"
        echo -e "${col[fg_purple]}[${col[reset]}=====${col[fg_purple]}DEBUG${col[reset]}=====${col[fg_purple]}]${col[reset]}"
}


timing[printouts]="$EPOCHREALTIME"
# Color banner 
local col_banner
printf -v col_banner "%b%-$(( COLUMNS / 30 ))b" \
    "" "" \
    "          ${col[fg_blue]}dt" "\n"\
    "          I@@w       ${col[fg_magenta]}Starship Prompt" "\n"\
    "         ${col[fg_blue]}r@@@@l                ${col[fg_light_grey]}using" "\n"\
    "        ${col[fg_blue]}f#@@@@#b    ${col[fg_orange]}<Name TBD> ${col[fg_light_grey]}theme" "\n"\
    "     ${col[fg_blue]},%gg@@@@@@0}m,   ${col[fg_light_grey]}by ${col[fg_yellow]}@TomIO#2000" "\n"\
    "   ${col[fg_blue]}yPwZ/@@@@@@@@Âµ&oPa" "\n"\
    " ;O0Â´  Q@@@@@@@@\$  \`r6." "\n"\
    "(QÂ°   .@@@@@@@@@@;   \`0," "\n"\
    "Gj    G@@@@@@@@@@Q    kD" "\n"\
    "Q    ,@@@@@@%^}@@@;   ;g" "\n"\
    "Vy   A@@@@QÂ°   v@@0   q)" "\n"\
    " uP.y@@@#%      v@@l dv" "\n"\
    "  ?o\$@@6%        k@8y'" "\n"\
    "    ##zEosyuyweaIuMQ" "\n"\
    "   Â´%Â°             m${col[reset]}"

[[ ! $debug_verbosity =~ ^(banner|all|)$ ]] && { ## Debug banner: # (RegEx) Only redefine the banner if $debug_verbosity isn't 'banner', 'all' or unset
    printf -v col_banner "%b${col[reset]}" \
      "${col[fg_green]}${col[bg_dark_grey]}D" "${col[fg_yellow]}   ${col[uline]}__${col[no_uline]}" \
    "\n${col[fg_green]}${col[bg_dark_grey]}e" "${col[fg_yellow]} <(${col[reset]}o ${col[fg_yellow]})${col[uline]}___${col[no_uline]}" \
    "\n${col[fg_green]}${col[bg_dark_grey]}b" "${col[fg_yellow]}  ( .${col[uline]}_${col[no_uline]}> /" \
    "\n${col[fg_green]}${col[bg_dark_grey]}u" "${col[fg_yellow]}   \`${col[uline]}___${col[no_uline]}/" \
    "\n${col[fg_green]}${col[bg_dark_grey]}g${col[reset]}"; }


    [[ -z $ANDROID_ROOT ]] && echo -e "$col_banner" # test that we're not on Android/Termux.
    [[ -n $STARSHIP_SHELL ]] && echo -e "ðŸš€ Starship Prompt Initialized" # print confirmation message if starship successfully started

{ # <> See if we should be using the working tree versions of starship.toml
    if   [[ -e /mnt/c/Users/Josh/Desktop/stuff/VScode/git/.dotfiles/dot_config/private_starship.toml ]]; then # if this is my personal PC, use the working copy of the prompt
            export STARSHIP_CONFIG="/mnt/c/Users/Josh/Desktop/stuff/VScode/git/.dotfiles/dot_config/private_starship.toml"
    elif [[ -e $HOME/git/.dotfiles/dot_config/private_starship.toml ]]; then # same check for my personal laptop
            export STARSHIP_CONFIG="$HOME/git/.dotfiles/dot_config/private_starship.toml"
    elif [[ -e /mnt/c/Users/PC/Desktop/VSCode/git/.dotfiles/dot_config/private_starship.toml ]]; then # same check but for my work laptop
            export STARSHIP_CONFIG="/mnt/c/Users/PC/Desktop/VSCode/git/.dotfiles/dot_config/private_starship.toml"
    fi
}

if [[ ! -S "$SSH_AUTH_SOCK" ]]; then # <> see if SSH Agent is running
    eval "$(ssh-agent)" > /dev/null # startup the SSH Agent; discard confirmation message
    echo -e "SSH Agent started\nPID: ${col[inv]}$SSH_AGENT_PID${col[reset]}"
fi

[[ $debug_verbosity =~ ^(ssh|all)$ ]] && { ## Debug: SSH # (RegEx) Only define this if $debug_verbosity is 'ssh' or 'all'
    echo -e "$( eval ls -d1 "${SSH_AUTH_SOCK//\/ssh*//ssh*}" | wc -l ) SSH agents running" || echo "Could not determine SSH Debug information"
}

### Update checking
# shellcheck disable=SC2207 # ?? We're taking care of this ourselves
declare -a found_plugins=($(find "$zsh_script_dir" -mindepth 1 -maxdepth 1 -type d)) # list of installed plugins

timing[printouts]=$(printf '%8.2f%s' "$(( (EPOCHREALTIME - timing[printouts]) * 1000 ))" "ms â”‚  â”Œâ”€ Printouts - main:$LINENO")

    function updates(){ # <> Everything relating to update checking.

        [[ ! -d $zsh_script_dir || ! -e $zsh_script_dir ]] && mkdir -p "$zsh_script_dir" # if script dir doesn't exist, make it.
        echo -e "Last checked for updates at: ${col[fg_blue]}$(date -r "$zsh_script_dir" +"%x %X" || echo "Unknown")${col[reset]}"

        function parse_frequency(){ # <> Resolve $update_frequency from human readable form to seconds.
            [[ $debug_verbosity =~ ^(updates|all)$ ]] && return # If we are debugging updates, this is irrelevant.

            local minute="60" # Seconds
            local hour="$((60 * minute))"
            local day="$((24 * hour))"
            local week="$((7 * day))"

            if [[ $update_frequency =~ ^[0-9]+$ ]]; then # If the value is numeric, just use it as is (no-op)
                : # If the update frequency is a integer, take it as is.
            elif [[ $update_frequency =~ ^([0-9]+[SsMmHhDdWw])+$ ]]; then
                update_frequency=$(( $(sed -E "s/[Ww]/ \* $week + /;s/[Dd]/ \* $day + /;s/[Hh]/ \* $hour + /;s/[Mm]/ \* $minute + /;s/[Ss]//" <<< $update_frequency) + 0 )) # replace each letter with its corresponding conversion constant, then sum them up; this fails without an operation on the sed output, so we just do + 0
            else # Fallthrough in case of invalid pattern
                printf '%b' \
                "${col[fg_red]}Error:${col[reset]} " \
                "Could not resolve value for " \
                "${col[fg_orange]}${col[uline]}\$update_frequency=${col[reset]}\"${update_frequency:-<unset>}\" " \
                "defaulting to 1 Week\n"
                update_frequency="$((1 * week ))"
            fi
        return
        }; parse_frequency

        [[ $debug_verbosity =~ ^(updates|all)$ || $(( EPOCHSECONDS - $(date -r "$zsh_script_dir" +%s) )) -ge "$update_frequency" ]] && { # <> This only runs if the update_frequency has passed or we're debugging this
            check_upstream() { # (ACK) Based on https://stackoverflow.com/a/3278427

                local UPSTREAM; UPSTREAM='@{u}'
                local LOCAL   ; LOCAL=$(git rev-parse '@{0}')
                local REMOTE  ; REMOTE=$(git rev-parse "$UPSTREAM")
                local BASE    ; BASE=$(git merge-base '@{0}' "$UPSTREAM")

                if [ "$LOCAL" = "$REMOTE" ]; then
                    echo -e "[${col[fg_green]}${PWD##*\/}${col[reset]}] Up to date" # Remove all but the last part of the directory name, leaving the plugin name.
                elif [ "$LOCAL" = "$BASE" ]; then
                    echo -e "[${col[fg_orange]}${PWD##*\/}${col[reset]}] New changes available"
                    touch -cm . # Update the modification time of this plugin's folder.
                    ### (todo) Prompt user for update. (I'll add this later)
                fi
            return
            }

            for index in "${found_plugins[@]}"; do # loop over the array of plugins
                [[ ${plugins[${index##*\/}]:0:1} == '/' ]] && { printf '%b' "[${col[fg_green]}${index##*\/}${col[reset]}] Local Plugin\n"; continue; }
                ( cd "$index" && check_upstream ) # Do update checking in a subshell to avoid having to cd back inside of the parent shell
            done
            touch -cm "$zsh_script_dir" # Update the script directories modification time.
        }
    }; timing[updates]="$EPOCHREALTIME"; updates; timing[updates]=$(printf '%8.2f%s' "$(( (EPOCHREALTIME - timing[updates]) * 1000 ))" "ms â”‚  â”œâ”€ Update checking - main:$LINENO") # Run the updates function, since we're done defining it.

    timing[plugins]="$EPOCHREALTIME"
    ### Evaluate missing plugins
[[ $debug_verbosity =~ ^("missing"|"all")$ ]] && { ## Debug: Missing plugins # (RegEx) Only define this if $debug_verbosity is 'missing' or 'all'
    debug_plugins=( # Add a couple fake missing plug-ins for debugging
        "https://127.0.0.1/fake_plugin/zsh-fake-plugin"
        "https://127.0.0.1/fake_plugin/zsh-not-a-real-plugin"
        "https://127.0.0.1/fake_plugin/zsh-also-not-a-real-plugin"
        "https://127.0.0.1/fake_plugin/zsh-get-real"
        "https://127.0.0.1/fake/zsh-fake-debug-plugins"
        "/home/tom/.config/zsh/scripts/local-fake"
        "/home/tom/.config/zsh/scripts/another-local-fake"
    ) # Then print out the lists.
    printf "%b${col[reset]}\n" \
    "${col[fg_purple]}DEBUG:${col[reset]} Adding some fake plugins for missing detection" \
    "${col[fg_purple]}Wanted:" \
    "${plugins[@]/#/${col[fg_orange]}}" \
    "${debug_plugins[@]/#/${col[blink]}${col[fg_orange]}}" \
    "${col[fg_purple]}Found:" \
    "${found_plugins[@]/#/${col[fg_green]}}"
}

declare -a p_diff # Array of missing plugins
local p_diff=() # (ACK) Based on: https://stackoverflow.com/a/2315459
    # shellcheck disable=SC2068,SC2296 # ?? Shellcheck doesn't understand Zsh's method for looping over associative array keys.
    for wanted in ${(k)plugins[@]##*\/}; do
        local skip=''
        for found in "${found_plugins[@]##*\/}"; do
            [[ "$wanted" == "$found" ]] && { skip=1; break; }
        done
        [[ -n $skip ]] || p_diff+=("$wanted")
    done

[[ $debug_verbosity =~ ^("missing"|"all")$ ]] && printf "%b" "${p_diff[@]}" ## Debug: Missing plugins # (RegEx) Only define this if $debug_verbosity is 'missing' or 'all'

# [[ -n ${p_diff[*]} ]] && printf "${col[fg_red]}%b${col[reset]} Missing:\n" "${p_diff[@]}" # (WIP)


unset -v "found_plugins[@]" "p_diff[@]" "skip" # Unset variables needed for missing script detection
timing[plugins]=$(printf '%8.2f%s' "$(( (EPOCHREALTIME - timing[plugins]) * 1000 ))" "ms â”‚  â”œâ”€ Plugin checking - main:$LINENO")

### Shell Options
setopt AUTO_CD # cd can be omitted when typing in a valid file path
setopt CDABLE_VARS # expand variable for changing directories


### Completions

# zstyle ':completion:*:man:*' menu yes select # (WIP)
fpath+=("$zsh_script_dir/zsh-completions") # Zsh Completions does not get sourced, it gets appended to $fpath


### History Setup
export HISTFILE="$HOME/.histfile"
export HISTSIZE=4000
export SAVEHIST=10000

### Environment setup.
export LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.swp=00;90:*.tmp=00;90:*.dpkg-dist=00;90:*.dpkg-old=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90:' # set custom $LS_COLORS

    function path_amend(){
        local add_to_path=(
            "$HOME/.cargo/bin"
        )

        for P in "${add_to_path[@]}"; do
            [[ "$PATH" =~ (^|:)$P(:|$) ]] || export PATH="$PATH:$P" # (RegEx) Check if the desired variable is in $PATH, otherwise amend it to $PATH
        done
    }; path_amend

### less pager stylization
    LESS_TERMCAP_mb=$(echo -e "${col[fg_red]}")               ; export LESS_TERMCAP_mb # #D61E1C
    LESS_TERMCAP_md=$(echo -e "${col[fg_blue]}")              ; export LESS_TERMCAP_md # #0A75AD
    LESS_TERMCAP_me=$(echo -e "${col[reset]}")                ; export LESS_TERMCAP_me
    LESS_TERMCAP_se=$(echo -e "${col[reset]}")                ; export LESS_TERMCAP_se
    LESS_TERMCAP_so=$(echo -e "${col[fg_yellow]}")            ; export LESS_TERMCAP_so # #EDBC00
    LESS_TERMCAP_ue=$(echo -e "${col[reset]}")                ; export LESS_TERMCAP_ue
    LESS_TERMCAP_us=$(echo -e "${col[uline]}${col[fg_green]}"); export LESS_TERMCAP_us # #1DA65A

# setup nvim as default EDITOR and DIFF program.
export EDITOR="nvim"
export DIFFPROG="nvim -d"

alias ls='LC_COLLATE=C ls --color=auto' # colorize ls by default

# (WIP) - SSH disconnect command keepalive
# noclose() { # Keep passed task running in background, even after SSH disconnection
#     (nohup "$@" &>/dev/null &)
# }

# (WIP)
# ssh-keygen -t rsa -b 4096 -f /mnt/c/Users/PC/Desktop/SSH/rsa-4096_github -C "$(whoami)@$(uname -n)-$(date -I)"

# (WIP)
# alias raw-input='sed -n l' # make the terminal print the raw input characters to the screen

### Load "plug-in" scripts; explicitly.
# shellcheck source=/dev/null # ?? Ignore Shellcheck's inability to parse external sources by default
source "$zsh_script_dir/zsh-autosuggestions/zsh-autosuggestions.zsh" 2> /dev/null # Load autosuggestions

# shellcheck source=/dev/null # ?? Ignore Shellcheck's inability to parse external sources by default
source "$zsh_script_dir/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" 2> /dev/null # Syntax highlighting; should be loaded last
}

function parse_args(){ # (ACK) Based on: https://stackoverflow.com/a/14203146

    function get_new_verbosity(){
    while true; do
        local user_input='' # reset input
        printf "%b${col[reset]} " "Valid options:" "${debug_valid[@]/#/${col[bold]}${col[inv]}}" "\n${col[fg_green]}Please provide a valid setting for verbosity:"
        read -r user_input
        if [[ "${debug_valid[*]}" =~ (^|[[:space:]])$user_input($|[[:space:]]) ]]; then # the \s RegEx shorthand for whitespace does not work in test expressions, need to fallback to [[:space:]]
            debug_verbosity=$user_input; return
        fi
    done
    }

# shellcheck disable=SC2068,SC2296 # ?? Shellcheck doesn't understand Zsh's method for looping over associative array keys.
{ # <> Version and dependency information
local name="TomIO's .zshrc"
local version="${col[uline]}${col[fg_yellow]}v1.1.0${col[reset]}"
local license="${col[fg_green]}AGPLv3${col[reset]}"
local dependencies; printf -v dependencies '%b' \
    "${col[orange]}${col[uline]}Dependencies:${col[reset]}\n" \
    " - Shell" "Zsh${col[reset]} (MIT License)\n" \
    " - Utils: " "${col[dim]}GNU${col[no_dim]} Coreutils${col[reset]} (GPLv3+)\n" \
    " - Update Checking/Version Control: " "Git${col[reset]}\n" \
    " - Remote Access: " "OpenSSH\n" \
    "Plugins: " \
    "$( paste -d '' <(printf "%s -> \n" ${(k)plugins[@]}) <(printf "%s\n" "${plugins[@]}") )" "\n" \
    "\n"
}

local posargs=''
    while (( "$#" )); do
        case "$1" in
        '-v'|'--verbose')
            echo -ne "Found ${col[uline]}${col[ital]}${col[fg_cyan]}'$1'${col[reset]} with option: ${col[uline]}${col[ital]}${col[fg_cyan]}'${2:-<none>}'${col[reset]} "
            if [[ -n "$2" && ${2:0:1} != "-" && ${debug_valid[*]} =~ (^|[[:space:]])$2($|[[:space:]]) ]]; then
                debug_verbosity="$2"
                shift "2"
            else
                echo -e "which is invalid."
                get_new_verbosity
                shift "$(( ( ${#2} != 0 ) + 1 ))"
            fi
            echo
        ;;
        '-h'|'-?'|'--help')
            debug_verbosity='off' # ?? This will make main() print the debug banner, which is more compact
            echo -e "I haven't written a --help output yet"
            break
        ;;
        '-V'|'--version')
            debug_verbosity='off' # ?? This will make main() print the debug banner, which is more compact
            printf '%b' \
            "$name $version | License: $license\n" \
            "$dependencies"
            break
        ;;
        '--')
            shift # shift -- off the stack
            posargs="$posargs $*" # add remaining args to $posargs
            [[ $debug_verbosity =~ ^(args|all)$ ]] && echo -e "Found ${col[uline]}${col[ital]}'--'${col[reset]}, stopping parsing.\nLeftover args: $*"
            break
        ;;
        --*=|--*|-*) # unknown flags
            echo "Unknown flag $1, ignoring"
            shift
        ;;
        *) # keep the order of positional arguments
            posargs="$posargs $1"
            shift
        ;;
        esac
    done
    eval set -- "$posargs" # restore positional arguments
return
}
[[ "$#" ]] && timing[args]="$EPOCHREALTIME"; parse_args "$@" # if args were passed, parse them
timing[args]=$(printf '%8.2f%s' "$(( (EPOCHREALTIME - timing[args]) * 1000 ))" "ms â”œâ”€ parse_args() - L:$LINENO")

[[ ( "$SHLVL" == 1 ) || ! $debug_verbosity =~ ^(off|)$ ]] && timing[main]="$EPOCHREALTIME"; main # Only run `main()` if we're in a un-nested shell, or debugging.
timing[main]=$(printf '%8.2f%s' "$(( (EPOCHREALTIME - timing[main]) * 1000 ))" "ms â””â”€ main() - L:$LINENO")


### initialize starship prompt, this needs to be done in every nested shell.
eval "$(starship init zsh)" || \
echo "Error: failed to initialize starship prompt"# Print error message if starship failed to initialize

### Cleanup of remaining variables and functions.
unset -f "setup" "main" "parse_args" # unset functions
unset -v "plugins[@]" "debug_valid[@]" "debug_verbosity" # debug related variables

# <> Timing printout
printf '%b' \
"${timing[plugin_list]}\n" \
"${timing[color]}\n" \
"${timing[debug]}\n" \
"${timing[setup]}\n" \
"${timing[args]:=Args\:   not run}\n" \
"${timing[printouts]}\n" \
"${timing[updates]}\n" \
"${timing[plugins]}\n" \
"${timing[main]:=main()\: not run}\n"

printf '%8.2f%s\n' "$(( (EPOCHREALTIME - timing[all]) * 1000 ))" "ms - Total time"
unset -v "timing[@]"

# [============================Helpful resources============================]
# [ Hyperpolyglot.org's comparison of *NIX shell syntax                     ]
# [ https://hyperpolyglot.org/unix-shells                                   ]
# [                                                                         ]
# [ Dylan Araps' collection of pure Bash alternatives to external processes ]
# [ https://github.com/dylanaraps/pure-bash-bible                           ]
# [                                                                         ]
# [ Advanced Bash Scripting Guide                                           ]
# [ https://tldp.org/LDP/abs/html/index.html                                ]
# [                                                                         ]
# [ Shellscript Linter                                                      ]
# [ https://www.shellcheck.net/                                             ]
# [                                                                         ]
# [ Zsh ZLE and bindkey reference                                           ]
# [ https://stackoverflow.com/a/55235069                                    ]
# [=========================================================================]
